# Day 18: Exception Filters

## üìù Today's Tasks

1.  **Understand Exception Filters:** Learn how exception filters work and their place in the NestJS request lifecycle.
2.  **Catch Built-in Exceptions:** Use the `@Catch()` decorator to catch specific types of exceptions (e.g., `HttpException`).
3.  **Create a Global Exception Filter:** Build a global exception filter to handle all unhandled exceptions in your application.
4.  **Customize Error Responses:** Use an exception filter to create a consistent and user-friendly error response format for your API.

## üìñ Task Explanations

Proper error handling is a hallmark of a professional API. NestJS provides a powerful exception filter layer that gives you full control over how exceptions are handled and what response is sent to the client. Today, you will learn how to create exception filters to catch specific errors and how to build a global filter to ensure that your API always returns a well-structured error response, even when unexpected errors occur.

## üí° What You'll Gain

You will be able to build robust and user-friendly APIs by implementing a centralized and consistent error handling strategy. You will know how to handle both expected and unexpected errors gracefully.

## üìö Dictionary for Developers

*   **Exception Filter:** A class that implements the `ExceptionFilter` interface and is used to handle unhandled exceptions.
*   **`@Catch()`:** A decorator that binds an exception filter to a specific exception type.
*   **`HttpException`:** A built-in NestJS exception that can be used to represent HTTP errors.